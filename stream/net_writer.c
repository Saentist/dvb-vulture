#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/uio.h>
#include <poll.h>
#include <sys/time.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/ip.h>
#include <sys/ioctl.h>
#include <inttypes.h>
#include "in_out.h"
#include "utl.h"
#include "dvb.h"
#include "net_writer.h"
#include "config.h"
#include "sit_com.h"
#include "pidbuf.h"
#include "debug.h"
#include "dmalloc.h"

int DF_NETW;
#define FILE_DBG DF_NETW

#define TS_PACKET_SIZE TS_LEN

#define MTU 1200                /* Conservative estimate */
#define IP_HEADER (5*4)
#define UDP_HEADER (2*4)
#define MAX_DATAGRAM_SIZE (MTU - (IP_HEADER+UDP_HEADER))
#define RTP_HEADER_SIZE 12
#define MAX_TS_PACKETS_PER_DATAGRAM ((MAX_DATAGRAM_SIZE-RTP_HEADER_SIZE) / TS_PACKET_SIZE)
#define DEFAULT_TS_BUFSIZE ((MAX_TS_PACKETS_PER_DATAGRAM)*(TS_PACKET_SIZE))

static void
RTPHeaderInit (uint8_t * header, uint16_t sequence, uint64_t time)
{
  /*
     TODO
     we have to generate the timestamp a different way.
     the value we get here won't be smooth as the buffering introduces jitter.
     another downside is the considerable system load generated by frequent calls
     perhaps we can recover program time stamp or similar. system clock reference may do aswell.
     how deep do we have to dig into the packets to get those?
     0.7,0.7,0.1,0.7 seconds
     PTS,SCR,PCR,ESCR
     Ts_program_map_section->PCR_PID
     MPEG2_program_stream->pack->pack_header->SCR

     ts_header->adaptation_field->PCR


     Haha
     we could measure the outgoing data rate 
     smooth that value, 
     and calculate timestamps by the number of packets transferred.

     bitrate=num_bits/time

     time=num_bits/bitrate;

     data rate could be measured at larger intervals(seconds)

     we want: 1sec==90000 units

     alright, that didn't change anything, speed-wise

     perhaps use DMX_GET_STC
   */
//    gettimeofday(&tv,(struct timezone*) NULL);
  /* Flags and payload type */
  header[0] = (2 << 6);         /* Version 2, No Padding, No Extensions, No CSRC count */
  header[1] = 33;               /* No Marker, Payload type MP2T */

  /* Sequence */
  header[2] = (uint8_t) (sequence >> 8) & 0xff;
  header[3] = (uint8_t) (sequence >> 0) & 0xff;

  /* Time stamp */
//    temp = ((tv.tv_sec%1000000)*1000000 + tv.tv_usec)/11; /* approximately a 90Khz clock (1000000/90000 = 11.1111111...)*/
  header[4] = (time >> 32) & 0xff;
  header[5] = (time >> 24) & 0xff;
  header[6] = (time >> 16) & 0xff;
  header[7] = (time >> 8) & 0xff;

  /* SSRC (Not implemented) */
  header[8] = 0x0f;
  header[9] = 0x0f;
  header[10] = 0x0f;
  header[11] = 0x0f;
}

static void
net_writer_pk_clean (NetWriter * w, struct iovec *iov)
{
  int i;
  if (w->smi_pk)
  {
    i = 2;
  }
  else
  {
    i = 1;
  }
  for (; i < MAX_TS_PACKETS_PER_DATAGRAM + 1; i++)
  {
    uint8_t *d;
    d = iov[i].iov_base;
    if (d)
    {
      d = selectorPElement (d);
      selectorReleaseElementUnsafe (svtOutSelector (w->o), d);
      iov[i].iov_base = NULL;
      iov[i].iov_len = 0;
    }
  }
}

static void
net_writer_send (NetWriter * w, struct iovec *iov)
{
  struct msghdr msg = {
    .msg_name = (struct sockaddr *) (&w->dest_addr),
    .msg_namelen =
      (w->dest_addr.ss_family ==
       AF_INET) ? sizeof (struct sockaddr_in) : sizeof (struct sockaddr_in6),
    .msg_iov = iov,
    .msg_iovlen = MAX_TS_PACKETS_PER_DATAGRAM + 1,
    .msg_control = NULL,
    .msg_controllen = 0,
    .msg_flags = 0
  };

  RTPHeaderInit (iov[0].iov_base, w->sequence, w->t_ctr);
  selectorUnlock (svtOutSelector (w->o));
  if (sendmsg (w->bcast_sock, &msg, 0) < 0)
  {
    errMsg ("sendto error %s\n", strerror (errno));
  }
  selectorLock (svtOutSelector (w->o));
  w->sequence++;
  net_writer_pk_clean (w, iov);

}

//FIXME SIT/DIT has to be sent as soon as possible, so it's right on stream transition...
static void
net_writer_queue (NetWriter * w, uint8_t * d, struct iovec *iov, int *iov_ctr)
{
  iov[(*iov_ctr)].iov_base = d;
  iov[(*iov_ctr)].iov_len = TS_LEN;
  (*iov_ctr)++;
  if ((*iov_ctr) >= (MAX_TS_PACKETS_PER_DATAGRAM + 1))
  {
    net_writer_send (w, iov);
    (*iov_ctr) = 1;
    w->smi_pk = false;
    w->smi_intvl++;
    if (w->smi_intvl > 1000)
    {
      w->smi_intvl = 0;
      if (w->dit_ts)
      {
        uint8_t *ptr;
        w->smi_pk = true;
        ptr = TS_PTR (w->dit_ts, w->dit_ctr);
        ts_put_ctr (ptr, w->dit_cc);
        w->dit_cc = (w->dit_cc + 1) & 15;
        memmove (w->smi_ts_buf, ptr, TS_LEN);
        iov[(*iov_ctr)].iov_base = w->smi_ts_buf;
        iov[(*iov_ctr)].iov_len = TS_LEN;
        (*iov_ctr)++;
        w->dit_ctr++;
        if (w->dit_ctr >= w->num_dit_ts)
        {                       //we only send this once(until composition changes again)
          utlFAN (w->dit_ts);
          w->dit_ts = NULL;
          w->num_dit_ts = 0;
          w->dit_ctr = 0;
        }
      }
      else if (w->sit_ts)
      {
        uint8_t *ptr;
        w->ts_changed = 0;
        w->smi_pk = true;
        ptr = TS_PTR (w->sit_ts, w->sit_ctr);
        ts_put_ctr (ptr, w->sit_cc);
        w->sit_cc = (w->sit_cc + 1) & 15;
        memmove (w->smi_ts_buf, ptr, TS_LEN);
        iov[(*iov_ctr)].iov_base = w->smi_ts_buf;
        iov[(*iov_ctr)].iov_len = TS_LEN;
        (*iov_ctr)++;
        w->sit_ctr++;
        if (w->sit_ctr >= w->num_sit_ts)
          w->sit_ctr = 0;       //repeat from beginning
      }
    }
  }
}

void *
rate_estimator (void *p)
{
  NetWriter *w = p;
  taskLock (&w->est);
  while (taskRunning (&w->est))
  {
    taskUnlock (&w->est);
    sleep (3);

    taskLock (&w->t);
    if (w->pk_ctr != 0)
      w->delta_t = (3 * w->delta_t + (256 * 90000 * 3) / w->pk_ctr) / 4;
    debugMsg ("pk_ctr: %" PRIu32 " delta_t: %" PRIu32 "\n", w->pk_ctr,
              w->delta_t);
    w->pk_ctr = 0;
    taskUnlock (&w->t);
    taskLock (&w->est);
  }
  taskUnlock (&w->est);
  return NULL;
}

void *
do_stream (void *p)
{
  NetWriter *w = p;
  int s_rv;
  uint16_t pnr_dta;
//      uint8_t tsbuf[DEFAULT_TS_BUFSIZE+RTP_HEADER_SIZE];
  uint8_t header[RTP_HEADER_SIZE];
  struct iovec iov[MAX_TS_PACKETS_PER_DATAGRAM + 1];
  int iov_ctr = 1;
//      int offs;
  w->delta_t = 2000 * 256;
  w->pk_ctr = 0;
  taskStart (&w->est);

  memset (iov + 1, 0, sizeof (struct iovec) * MAX_TS_PACKETS_PER_DATAGRAM);     //to set unused entries NULL and 0(well, not everywhere...)
  iov[0].iov_base = header;
  iov[0].iov_len = RTP_HEADER_SIZE;
  taskLock (&w->t);
//      offs=0;
  debugMsg ("DEFAULT_TS_BUFSIZE: %" PRIu32 "\n",
            (uint32_t) DEFAULT_TS_BUFSIZE);
  while (taskRunning (&w->t))
  {
    taskUnlock (&w->t);
    s_rv = selectorWaitData (w->input, 300);
    taskLock (&w->t);
    if (!s_rv)
    {
      uint8_t *d;
      selectorLock (svtOutSelector (w->o));
      while ((d = selectorReadElementUnsafe (w->input)))
      {
        if (!selectorEIsEvt (d))
        {
          w->pk_ctr++;
          w->t_ctr += w->delta_t;
          net_writer_queue (w, selectorEPayload (d), iov, &iov_ctr);
        }
        else
        {
          selectorUnlock (svtOutSelector (w->o));       //we may need to call into pgmdb, which needs selector, too
          switch (selectorEvtId (d))
          {
          case E_TUNING:
            debugMsg ("E_TUNING\n");
            dvbDmxOutMod (w->o, 0, NULL, NULL, 0, NULL);
            w->tuned = 0;
            utlFAN (w->active_pnrs);
            w->active_pnrs = NULL;
            w->num_pnrs = 0;
            w->ts_changed = 1;
            break;
          case E_IDLE:
            debugMsg ("E_IDLE\n");
            dvbDmxOutMod (w->o, 0, NULL, NULL, 0, NULL);
            w->tuned = 0;
            utlFAN (w->active_pnrs);
            w->active_pnrs = NULL;
            w->num_pnrs = 0;
            w->ts_changed = 1;
            break;
          case E_TUNED:        //tuning successful
            debugMsg ("E_TUNED\n");
            w->tuned = 1;
            break;
          case E_PNR_ADD:
            debugMsg ("E_PNR_ADD\n");
            pnr_dta = selectorEvtDta (d)->pnr;
            netWriterAddPnr (w, pnr_dta);
            break;
          case E_PNR_RMV:
            debugMsg ("E_PNR_RMV\n");
            pnr_dta = selectorEvtDta (d)->pnr;
            netWriterRmvPnr (w, pnr_dta);
            break;
          default:
            break;
          }
          selectorLock (svtOutSelector (w->o));
          selectorReleaseElementUnsafe (svtOutSelector (w->o), d);
        }
      }
      selectorUnlock (svtOutSelector (w->o));
    }
  }
  debugMsg ("do_stream exit\n");
  selectorLock (svtOutSelector (w->o));
  net_writer_pk_clean (w, iov);
  selectorUnlock (svtOutSelector (w->o));
  taskUnlock (&w->t);
  taskStop (&w->est);
//      fclose(tsf);
  return NULL;
}

int
netWriterStart (NetWriter * w)
{
  debugMsg ("netWriterStart\n");
  return taskStart (&w->t);
}

int
netWriterStop (NetWriter * w)
{
  debugMsg ("netWriterStop\n");
  return taskStop (&w->t);
}

int
netWriterInit (NetWriter * w, RcFile * cfg, dvb_s * dvb, PgmDb * db)
{
  uint16_t port;
  long v;
  char *cv;
  int sockfd;
  char *bcast_addr;
  int bcast_ttl, loop;
  int stream_eit;
  int af;

  memset (w, 0, sizeof (NetWriter));
  af = DEFAULT_AF;
  if (!rcfileFindValInt (cfg, "SERVER", "af", &v))
  {
    if (v == 6)
      af = AF_INET6;
    if (v == 4)
      af = AF_INET;
  }
  debugMsg ("using af: %s\n", (af == AF_INET) ? "AF_INET" : "AF_INET6");
  bcast_addr = BCAST_ADDR (af);
  if (!rcfileFindVal (cfg, "SERVER", "bcast_addr", &cv))
  {
    bcast_addr = cv;
  }
  debugMsg ("using addr: %s\n", bcast_addr);
  port = BCAST_PORT;
  if (!rcfileFindValInt (cfg, "SERVER", "bcast_port", &v))
  {
    port = v;
  }
  debugMsg ("using port: %" PRIu16 "\n", port);
  bcast_ttl = BCAST_TTL;
  if (!rcfileFindValInt (cfg, "SERVER", "bcast_ttl", &v))
  {
    bcast_ttl = v;
  }
  debugMsg ("using ttl: %u\n", bcast_ttl);
  loop = 0;
  if (!rcfileFindValInt (cfg, "SERVER", "loop", &v))
  {
    loop = v;
  }
  debugMsg ("using loop: %u\n", loop);

  v = 0;
  rcfileFindValInt (cfg, "SERVER", "stream_eit", &v);
  stream_eit = ! !v;

  debugMsg ("stream_eit: %d\n", stream_eit);

  sockfd = ioUdpSocket (af, bcast_addr, port, bcast_ttl, loop, &w->dest_addr);
  if (-1 == sockfd)
    return 1;

  if (taskInit (&w->t, w, do_stream) || taskInit (&w->est, w, rate_estimator))
  {
    errMsg ("task failed to init\n");
    close (sockfd);
    return 1;
  }

  w->bcast_sock = sockfd;
  w->stream_eit = stream_eit;
  w->sit_ts = NULL;
  w->tuned = 0;
  w->dit_ts = NULL;
  w->num_sit_ts = 0;
  w->num_dit_ts = 0;
  w->pgmdb = db;
  w->dvb = dvb;
  w->o = dvbDmxOutAdd (w->dvb);
  w->input = svtOutSelPort (w->o);      //dvbGetTsOutput (w->dvb, NULL, 0);
  w->sit_ver = 0;
  w->sit_cc = 0;
  w->dit_cc = 0;
  w->smi_pk = 0;
  w->sit_ctr = 0;
  w->dit_ctr = 0;
  w->smi_intvl = 0;
  w->ts_changed = 0;
  return 0;
}

void
CUnetWriterClear (void *v)
{
  netWriterClear (v);
}

int
CUnetWriterInit (NetWriter * w, RcFile * cfg, dvb_s * dvb, PgmDb * db,
                 CUStack * s)
{
  int rv = netWriterInit (w, cfg, dvb, db);
  cuStackFail (rv, w, CUnetWriterClear, s);
  return rv;
}

void
netWriterClear (NetWriter * w)
{
  debugMsg ("netWriterClear\n");
  netWriterStop (w);
//      netWriterRemoveFilters(w);
  taskClear (&w->t);
  taskClear (&w->est);
  shutdown (w->bcast_sock, SHUT_RDWR);
  close (w->bcast_sock);
//      pthread_mutex_destroy(&w->in_mx);

  if (w->dit_ts)
    utlFAN (w->dit_ts);
  w->dit_ts = NULL;

  if (w->sit_ts)
    utlFAN (w->sit_ts);
  w->sit_ts = NULL;

  if (w->active_pnrs)
    utlFAN (w->active_pnrs);
  w->active_pnrs = NULL;
  if (w->input)
  {
    dvbDmxOutRmv (w->o);
//    dvbTsOutputClear (w->dvb, w->input);
    w->o = NULL;
    w->input = NULL;
  }
  debugMsg ("netWriterClear done\n");
}

static int
check_pidbuf_size (uint16_t ** pidbuf, int *pidbuf_sz, int j)
{
  void *d;
  int sz = *pidbuf_sz;
  if (j >= sz)
  {
    d = utlRealloc (*pidbuf, sz *= 2);
    if (!d)
      utlFAN (*pidbuf);
    *pidbuf = d;
    *pidbuf_sz = sz;
  }
  return 0;
}


static int
net_writer_reinit (NetWriter * w)
{
//  ES *stream_info = NULL;
//  ProgramInfo *pgi = NULL;
  uint8_t sit[4096];
  uint8_t dit[4096];
  int sit_len;
  int dit_len;
  uint8_t *sit_ts = NULL;
  uint32_t num_sit_ts = 0;
  uint8_t *dit_ts = NULL;
  uint32_t num_dit_ts = 0;
//  int num, i, j, k;
//  int num_pgmi;
  uint16_t *funcs;
//  int pidbuf_sz;
  uint16_t eit_pid = 0x0012;
  debugMsg ("net_writer_reinit\n");

//      pthread_mutex_lock(&w->in_mx);
//  selectorModPort (w->input, NULL, 0);    //so the queue doesn't fill up during pgmdb ops, we probably also need a function to empty the queue
/*
  pidbuf_sz = 64;
  pidbuf = utlCalloc (pidbuf_sz, sizeof (uint16_t));
  j = 0;
  if (w->num_pnrs)
  {
    pidbuf[0] = 0;
    pidbuf[1] = 17;
    j=2;
    if(w->stream_eit)
    {
      pidbuf[2] = 0x0012;
      j++;
    }
  }
  for (i = 0; i < w->num_pnrs; i++)
  {
    uint16_t pcr_pid = 0x1fff;
//      pgmdbSetPgm(w->pgmdb,w->active_pnrs[i]);
    pgi =
      pgmdbFindPgmPnr (w->pgmdb, w->dvb->pos, w->dvb->freq, w->dvb->pol,
                       w->active_pnrs[i], &num_pgmi);
    if (pgi)
    {
      if (!pidbufContains (pgi->pid, pidbuf, j))
      {
        debugMsg ("Added Pid: %hu\n", pgi->pid);
        check_pidbuf_size (&pidbuf, &pidbuf_sz, j + 1);
        pidbuf[j] = pgi->pid;
        j++;
      }

      stream_info =
        pgmdbListStreams (w->pgmdb, w->dvb->pos, w->dvb->freq, w->dvb->pol,
                          w->active_pnrs[i], &pcr_pid, &num);
      if (stream_info)
      {
        if ((pcr_pid != 0x1fff) && (!pidbufContains (pcr_pid, pidbuf, j)))
        {
          debugMsg ("Added PcrPid: %hu\n", pcr_pid);
          check_pidbuf_size (&pidbuf, &pidbuf_sz, j + 1);
          pidbuf[j] = pcr_pid;
          j++;
        }
        for (k = 0; k < num; k++)
        {
          if (!pidbufContains (stream_info[k].pid, pidbuf, j))
          {
            debugMsg ("Added Pid: %hu\n", stream_info[k].pid);
            check_pidbuf_size (&pidbuf, &pidbuf_sz, j + 1);
            pidbuf[j] = stream_info[k].pid;
            j++;
          }
        }
        clear_es_infos (stream_info, num);
        utlFAN (stream_info);
      }
      else
        errMsg ("Stream Listing failed\n");
      programInfoClear (pgi);
      utlFAN (pgi);
    }
    else
      errMsg ("Failed to get Program info\n");
  }
  selectorModPort (w->input, pidbuf, j);
*/
  funcs = utlCalloc (sizeof (uint16_t), w->num_pnrs);
  memset (funcs, 0xff, sizeof (uint16_t) * w->num_pnrs);
  dvbDmxOutMod (w->o, w->num_pnrs, w->active_pnrs, funcs,
                (w->stream_eit) ? 1 : 0, &eit_pid);
  if (w->sit_ts)
    utlFAN (w->sit_ts);
  w->sit_ts = NULL;
  w->num_sit_ts = 0;

  if (w->dit_ts)
    utlFAN (w->dit_ts);
  w->dit_ts = NULL;
  w->num_dit_ts = 0;

  if (funcs)
    utlFAN (funcs);

  sit_ts = NULL;
  dit_ts = NULL;
  num_sit_ts = 0;
  num_dit_ts = 0;
  w->sit_ctr = 0;
  w->dit_ctr = 0;
  sit_len = sitCompile (w->active_pnrs, w->num_pnrs, w->sit_ver, sit);
  w->sit_ver = (w->sit_ver + 1) & 31;
  if (sit_len)
  {
    sit_ts = sec_to_ts (sit, sit_len, SIT_PID, &num_sit_ts);
    w->sit_ts = sit_ts;
    w->num_sit_ts = num_sit_ts;
  }

  dit_len = ditCompile (w->ts_changed, dit);
  w->ts_changed = 0;
  if (dit_len)
  {
    dit_ts = sec_to_ts (dit, dit_len, DIT_PID, &num_dit_ts);
    w->smi_intvl = 1000;
    w->dit_ts = dit_ts;
    w->num_dit_ts = num_dit_ts;
  }

  debugMsg ("net_writer_reinit done\n");
  return 0;
}

int
netWriterAddPnr (NetWriter * w, uint16_t pnr)
{
  debugMsg ("netWriterAddPnr\n");
  if (NULL == pidbufAddPid (pnr, &w->active_pnrs, &w->num_pnrs))
    return 1;
  if (net_writer_reinit (w))
    return 1;
  return 0;
}

int
netWriterRmvPnr (NetWriter * w, uint16_t pnr)
{
  debugMsg ("netWriterRmvPnr\n");
  pidbufRmvPid (pnr, &w->active_pnrs, &w->num_pnrs);
  if (net_writer_reinit (w))
    return 1;
  return 0;                     //dvbPnrRmvEvt(w->dvb,pnr);
}

int
netWriterRmvAll (NetWriter * w)
{
  debugMsg ("netWriterRmvAll\n");
  if (w->active_pnrs)
  {
    utlFAN (w->active_pnrs);
    w->active_pnrs = NULL;
  }
  w->num_pnrs = 0;
  return net_writer_reinit (w);
}

int
netWriterIdle (NetWriter * db)
{
  int rv;
  taskLock (&db->t);
  rv = (0 == db->tuned);
  taskUnlock (&db->t);
  return rv;
}
